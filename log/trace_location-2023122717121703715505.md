Generated by [trace_location](https://github.com/yhirano55/trace_location) at 2023-12-27 17:18:25 -0500

<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:182</summary>

##### ActiveSupport::Dependencies::ModuleConstMissing.const_missing

```ruby
def const_missing(const_name)
  from_mod = anonymous? ? guess_for_anonymous(const_name) : self
  Dependencies.load_missing_constant(from_mod, const_name)
end

# called from app/controllers/movies_controller.rb:11
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/anonymous.rb:16</summary>

##### Module.anonymous?

```ruby
def anonymous?
  name.nil?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:183
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:475</summary>

##### ActiveSupport::Dependencies.load_missing_constant

```ruby
def load_missing_constant(from_mod, const_name)
  log_call from_mod, const_name

  unless qualified_const_defined?(from_mod.name) && Inflector.constantize(from_mod.name).equal?(from_mod)
    raise ArgumentError, "A copy of #{from_mod} has been removed from the module tree but is still active!"
  end

  qualified_name = qualified_name_for from_mod, const_name
  path_suffix = qualified_name.underscore

  file_path = search_for_file(path_suffix)

  if file_path
    expanded = File.expand_path(file_path)
    expanded.sub!(/\.rb\z/, '')

    if loading.include?(expanded)
      raise "Circular dependency detected while autoloading constant #{qualified_name}"
    else
      require_or_load(expanded, qualified_name)
      raise LoadError, "Unable to autoload constant #{qualified_name}, expected #{file_path} to define it" unless from_mod.const_defined?(const_name, false)
      return from_mod.const_get(const_name)
    end
  elsif mod = autoload_module!(from_mod, const_name, qualified_name, path_suffix)
    return mod
  elsif (parent = from_mod.parent) && parent != from_mod &&
        ! from_mod.parents.any? { |p| p.const_defined?(const_name, false) }
    # If our parents do not have a constant named +const_name+ then we are free
    # to attempt to load upwards. If they do have such a constant, then this
    # const_missing must be due to from_mod::const_name, which should not
    # return constants from from_mod's parents.
    begin
      # Since Ruby does not pass the nesting at the point the unknown
      # constant triggered the callback we cannot fully emulate constant
      # name lookup and need to make a trade-off: we are going to assume
      # that the nesting in the body of Foo::Bar is [Foo::Bar, Foo] even
      # though it might not be. Counterexamples are
      #
      #   class Foo::Bar
      #     Module.nesting # => [Foo::Bar]
      #   end
      #
      # or
      #
      #   module M::N
      #     module S::T
      #       Module.nesting # => [S::T, M::N]
      #     end
      #   end
      #
      # for example.
      return parent.const_missing(const_name)
    rescue NameError => e
      raise unless e.missing_name? qualified_name_for(parent, const_name)
    end
  end

  name_error = NameError.new("uninitialized constant #{qualified_name}", const_name)
  name_error.set_backtrace(caller.reject {|l| l.starts_with? __FILE__ })
  raise name_error
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:184
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:476
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:478
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:478
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:467</summary>

##### ActiveSupport::Dependencies.qualified_name_for

```ruby
def qualified_name_for(mod, name)
  mod_name = to_constant_name mod
  mod_name == "Object" ? name.to_s : "#{mod_name}::#{name}"
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:482
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:468
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:118</summary>

##### String#underscore

```ruby
def underscore
  ActiveSupport::Inflector.underscore(self)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:483
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:91</summary>

##### ActiveSupport::Inflector.underscore

```ruby
def underscore(camel_cased_word)
  return camel_cased_word unless camel_cased_word =~ /[A-Z-]|::/
  word = camel_cased_word.to_s.gsub(/::/, '/')
  word.gsub!(/(?:(?<=([A-Za-z\d]))|\b)(#{inflections.acronym_regex})(?=\b|[^a-z])/) { "#{$1 && '_'}#{$2.downcase}" }
  word.gsub!(/([A-Z\d]+)([A-Z][a-z])/,'\1_\2')
  word.gsub!(/([a-z\d])([A-Z])/,'\1_\2')
  word.tr!("-", "_")
  word.downcase!
  word
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:119
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:203</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:94
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:30</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:207
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:31
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:403</summary>

##### ActiveSupport::Dependencies.search_for_file

```ruby
def search_for_file(path_suffix)
  path_suffix = path_suffix.sub(/(\.rb)?$/, ".rb")

  autoload_paths.each do |root|
    path = File.join(root, path_suffix)
    return path if File.file? path
  end
  nil # Gee, I sure wish we had first_match ;-)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:485
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.autoload_paths

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:406
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:434</summary>

##### ActiveSupport::Dependencies.autoload_module!

```ruby
def autoload_module!(into, const_name, qualified_name, path_suffix)
  return nil unless base_path = autoloadable_module?(path_suffix)
  mod = Module.new
  into.const_set const_name, mod
  autoloaded_constants << qualified_name unless autoload_once_paths.include?(base_path)
  mod
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:498
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:416</summary>

##### ActiveSupport::Dependencies.autoloadable_module?

```ruby
def autoloadable_module?(path_suffix)
  autoload_paths.each do |load_path|
    return load_path if File.directory? File.join(load_path, path_suffix)
  end
  nil
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:435
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.autoload_paths

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:417
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:30</summary>

##### Module.parent

```ruby
def parent
  parent_name ? ActiveSupport::Inflector.constantize(parent_name) : Object
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:500
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:7</summary>

##### Module.parent_name

```ruby
def parent_name
  if defined? @parent_name
    @parent_name
  else
    @parent_name = name =~ /::[^:]+\Z/ ? $`.freeze : nil
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:31
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:46</summary>

##### Module.parents

```ruby
def parents
  parents = []
  if parent_name
    parts = parent_name.split('::')
    until parts.empty?
      parents << ActiveSupport::Inflector.constantize(parts * '::')
      parts.pop
    end
  end
  parents << Object unless parents.include? Object
  parents
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:501
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:7</summary>

##### Module.parent_name

```ruby
def parent_name
  if defined? @parent_name
    @parent_name
  else
    @parent_name = name =~ /::[^:]+\Z/ ? $`.freeze : nil
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:48
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:182</summary>

##### ActiveSupport::Dependencies::ModuleConstMissing.const_missing

```ruby
def const_missing(const_name)
  from_mod = anonymous? ? guess_for_anonymous(const_name) : self
  Dependencies.load_missing_constant(from_mod, const_name)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:526
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/anonymous.rb:16</summary>

##### Module.anonymous?

```ruby
def anonymous?
  name.nil?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:183
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:475</summary>

##### ActiveSupport::Dependencies.load_missing_constant

```ruby
def load_missing_constant(from_mod, const_name)
  log_call from_mod, const_name

  unless qualified_const_defined?(from_mod.name) && Inflector.constantize(from_mod.name).equal?(from_mod)
    raise ArgumentError, "A copy of #{from_mod} has been removed from the module tree but is still active!"
  end

  qualified_name = qualified_name_for from_mod, const_name
  path_suffix = qualified_name.underscore

  file_path = search_for_file(path_suffix)

  if file_path
    expanded = File.expand_path(file_path)
    expanded.sub!(/\.rb\z/, '')

    if loading.include?(expanded)
      raise "Circular dependency detected while autoloading constant #{qualified_name}"
    else
      require_or_load(expanded, qualified_name)
      raise LoadError, "Unable to autoload constant #{qualified_name}, expected #{file_path} to define it" unless from_mod.const_defined?(const_name, false)
      return from_mod.const_get(const_name)
    end
  elsif mod = autoload_module!(from_mod, const_name, qualified_name, path_suffix)
    return mod
  elsif (parent = from_mod.parent) && parent != from_mod &&
        ! from_mod.parents.any? { |p| p.const_defined?(const_name, false) }
    # If our parents do not have a constant named +const_name+ then we are free
    # to attempt to load upwards. If they do have such a constant, then this
    # const_missing must be due to from_mod::const_name, which should not
    # return constants from from_mod's parents.
    begin
      # Since Ruby does not pass the nesting at the point the unknown
      # constant triggered the callback we cannot fully emulate constant
      # name lookup and need to make a trade-off: we are going to assume
      # that the nesting in the body of Foo::Bar is [Foo::Bar, Foo] even
      # though it might not be. Counterexamples are
      #
      #   class Foo::Bar
      #     Module.nesting # => [Foo::Bar]
      #   end
      #
      # or
      #
      #   module M::N
      #     module S::T
      #       Module.nesting # => [S::T, M::N]
      #     end
      #   end
      #
      # for example.
      return parent.const_missing(const_name)
    rescue NameError => e
      raise unless e.missing_name? qualified_name_for(parent, const_name)
    end
  end

  name_error = NameError.new("uninitialized constant #{qualified_name}", const_name)
  name_error.set_backtrace(caller.reject {|l| l.starts_with? __FILE__ })
  raise name_error
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:184
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:476
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:478
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:478
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:467</summary>

##### ActiveSupport::Dependencies.qualified_name_for

```ruby
def qualified_name_for(mod, name)
  mod_name = to_constant_name mod
  mod_name == "Object" ? name.to_s : "#{mod_name}::#{name}"
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:482
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:468
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:118</summary>

##### String#underscore

```ruby
def underscore
  ActiveSupport::Inflector.underscore(self)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:483
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:91</summary>

##### ActiveSupport::Inflector.underscore

```ruby
def underscore(camel_cased_word)
  return camel_cased_word unless camel_cased_word =~ /[A-Z-]|::/
  word = camel_cased_word.to_s.gsub(/::/, '/')
  word.gsub!(/(?:(?<=([A-Za-z\d]))|\b)(#{inflections.acronym_regex})(?=\b|[^a-z])/) { "#{$1 && '_'}#{$2.downcase}" }
  word.gsub!(/([A-Z\d]+)([A-Z][a-z])/,'\1_\2')
  word.gsub!(/([a-z\d])([A-Z])/,'\1_\2')
  word.tr!("-", "_")
  word.downcase!
  word
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:119
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:203</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:94
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:30</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:207
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:31
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:403</summary>

##### ActiveSupport::Dependencies.search_for_file

```ruby
def search_for_file(path_suffix)
  path_suffix = path_suffix.sub(/(\.rb)?$/, ".rb")

  autoload_paths.each do |root|
    path = File.join(root, path_suffix)
    return path if File.file? path
  end
  nil # Gee, I sure wish we had first_match ;-)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:485
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.autoload_paths

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:406
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.loading

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:491
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:333</summary>

##### ActiveSupport::Dependencies.require_or_load

```ruby
def require_or_load(file_name, const_path = nil)
  log_call file_name, const_path
  file_name = $` if file_name =~ /\.rb\z/
  expanded = File.expand_path(file_name)
  return if loaded.include?(expanded)

  # Record that we've seen this file *before* loading it to avoid an
  # infinite loop with mutual dependencies.
  loaded << expanded
  loading << expanded

  begin
    if load?
      log "loading #{file_name}"

      # Enable warnings if this file has not been loaded before and
      # warnings_on_first_load is set.
      load_args = ["#{file_name}.rb"]
      load_args << const_path unless const_path.nil?

      if !warnings_on_first_load or history.include?(expanded)
        result = load_file(*load_args)
      else
        enable_warnings { result = load_file(*load_args) }
      end
    else
      log "requiring #{file_name}"
      result = require file_name
    end
  rescue Exception
    loaded.delete expanded
    raise
  ensure
    loading.pop
  end

  # Record history *after* loading so first load gets warnings.
  history << expanded
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:494
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:334
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.loaded

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:337
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:253</summary>

##### Set#include?

```ruby
def include?(o)
  @hash[o]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:337
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.loaded

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:341
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:341
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.loading

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:342
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:345
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:346
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.warnings_on_first_load

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:353
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:450</summary>

##### ActiveSupport::Dependencies.load_file

```ruby
def load_file(path, const_paths = loadable_constants_for_path(path))
  log_call path, const_paths
  const_paths = [const_paths].compact unless const_paths.is_a? Array
  parent_paths = const_paths.collect { |const_path| const_path[/.*(?=::)/] || ::Object }

  result = nil
  newly_defined_paths = new_constants_in(*parent_paths) do
    result = Kernel.load path
  end

  autoloaded_constants.concat newly_defined_paths unless load_once_path?(path)
  autoloaded_constants.uniq!
  log "loading #{path} defined #{newly_defined_paths * ', '}" unless newly_defined_paths.empty?
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:354
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:451
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:456
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_methods/time_zone_conversion.rb:47</summary>

##### ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods.inherited

```ruby
def inherited(subclass)
  # We need to apply this decorator here, rather than on module inclusion. The closure
  # created by the matcher would otherwise evaluate for `ActiveRecord::Base`, not the
  # sub class being decorated. As such, changes to `time_zone_aware_attributes`, or
  # `skip_time_zone_conversion_for_attributes` would not be picked up.
  subclass.class_eval do
    matcher = ->(name, type) { create_time_zone_conversion_attribute?(name, type) }
    decorate_matching_attribute_types(matcher, :_time_zone_conversion) do |type|
      TimeZoneConverter.new(type)
    end
  end
  super
end

# called from app/models/movie.rb:1
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:17</summary>

##### ActiveRecord::AttributeDecorators::ClassMethods.decorate_matching_attribute_types

```ruby
def decorate_matching_attribute_types(matcher, decorator_name, &block)
  clear_caches_calculated_from_columns
  decorator_name = decorator_name.to_s

  # Create new hashes so we don't modify parent classes
  self.attribute_type_decorations = attribute_type_decorations.merge(decorator_name => [matcher, block])
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_methods/time_zone_conversion.rb:54
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attributes.rb:130</summary>

##### ActiveRecord::Attributes::ClassMethods.clear_caches_calculated_from_columns

```ruby
def clear_caches_calculated_from_columns
  @attributes_builder = nil
  @column_names = nil
  @column_types = nil
  @columns = nil
  @columns_hash = nil
  @content_columns = nil
  @default_attributes = nil
  @persistable_attribute_names = nil
  @attribute_names = nil
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:18
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:86</summary>

##### ActiveRecord::Base.attribute_type_decorations

```ruby
define_method(name) { val }

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:22
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:42</summary>

##### ActiveRecord::AttributeDecorators::TypeDecorator#merge

```ruby
def merge(*args)
  TypeDecorator.new(@decorations.merge(*args))
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:22
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:38</summary>

##### ActiveRecord::AttributeDecorators::TypeDecorator#initialize

```ruby
def initialize(decorations = {})
  @decorations = decorations
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:43
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:83</summary>

##### ActiveRecord::Base.attribute_type_decorations=

```ruby
define_singleton_method("#{name}=") do |val|
  singleton_class.class_eval do
    remove_possible_method(name)
    define_method(name) { val }
  end

  if singleton_class?
    class_eval do
      remove_possible_method(name)
      define_method(name) do
        if instance_variable_defined? ivar
          instance_variable_get ivar
        else
          singleton_class.send name
        end
      end
    end
  end
  val
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:22
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/remove_method.rb:2</summary>

##### Module.remove_possible_method

```ruby
def remove_possible_method(method)
  if method_defined?(method) || private_method_defined?(method)
    undef_method(method)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:85
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_methods.rb:64</summary>

##### ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods.inherited

```ruby
def inherited(subclass)
  # We need to apply this decorator here, rather than on module inclusion. The closure
  # created by the matcher would otherwise evaluate for `ActiveRecord::Base`, not the
  # sub class being decorated. As such, changes to `time_zone_aware_attributes`, or
  # `skip_time_zone_conversion_for_attributes` would not be picked up.
  subclass.class_eval do
    matcher = ->(name, type) { create_time_zone_conversion_attribute?(name, type) }
    decorate_matching_attribute_types(matcher, :_time_zone_conversion) do |type|
      TimeZoneConverter.new(type)
    end
  end
  super
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_methods/time_zone_conversion.rb:58
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_methods.rb:69</summary>

##### ActiveRecord::AttributeMethods::ClassMethods.initialize_generated_modules

```ruby
def initialize_generated_modules # :nodoc:
  @generated_attribute_methods = GeneratedAttributeMethods.new { extend Mutex_m }
  @attribute_methods_generated = false
  include @generated_attribute_methods

  super
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_methods.rb:65
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:60</summary>

##### Mutex.extend_object

```ruby
def Mutex_m.extend_object(obj) # :nodoc:
  super
  obj.mu_extended
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_methods.rb:70
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:65</summary>

##### Mutex_m.mu_extended

```ruby
def mu_extended # :nodoc:
  unless (defined? locked? and
          defined? lock and
          defined? unlock and
          defined? try_lock and
          defined? synchronize)
    Mutex_m.define_aliases(singleton_class)
  end
  mu_initialize
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:62
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:45</summary>

##### Mutex.define_aliases

```ruby
def Mutex_m.define_aliases(cl) # :nodoc:
  cl.module_eval %q{
    alias locked? mu_locked?
    alias lock mu_lock
    alias unlock mu_unlock
    alias try_lock mu_try_lock
    alias synchronize mu_synchronize
  }
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:71
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:108</summary>

##### Mutex_m.mu_initialize

```ruby
def mu_initialize # :nodoc:
  @_mutex = Thread::Mutex.new
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:73
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:199</summary>

##### ActiveRecord::AttributeMethods::ClassMethods.initialize_generated_modules

```ruby
def initialize_generated_modules # :nodoc:
  @generated_attribute_methods = GeneratedAttributeMethods.new { extend Mutex_m }
  @attribute_methods_generated = false
  include @generated_attribute_methods

  super
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_methods.rb:74
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:203</summary>

##### ActiveRecord::Core::ClassMethods.generated_association_methods

```ruby
def generated_association_methods
  @generated_association_methods ||= begin
    mod = const_set(:GeneratedAssociationMethods, Module.new)
    include mod
    mod
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:200
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/locking/optimistic.rb:179</summary>

##### ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods.inherited

```ruby
def inherited(subclass)
  # We need to apply this decorator here, rather than on module inclusion. The closure
  # created by the matcher would otherwise evaluate for `ActiveRecord::Base`, not the
  # sub class being decorated. As such, changes to `time_zone_aware_attributes`, or
  # `skip_time_zone_conversion_for_attributes` would not be picked up.
  subclass.class_eval do
    matcher = ->(name, type) { create_time_zone_conversion_attribute?(name, type) }
    decorate_matching_attribute_types(matcher, :_time_zone_conversion) do |type|
      TimeZoneConverter.new(type)
    end
  end
  super
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_methods.rb:66
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:17</summary>

##### ActiveRecord::AttributeDecorators::ClassMethods.decorate_matching_attribute_types

```ruby
def decorate_matching_attribute_types(matcher, decorator_name, &block)
  clear_caches_calculated_from_columns
  decorator_name = decorator_name.to_s

  # Create new hashes so we don't modify parent classes
  self.attribute_type_decorations = attribute_type_decorations.merge(decorator_name => [matcher, block])
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/locking/optimistic.rb:182
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attributes.rb:130</summary>

##### ActiveRecord::Attributes::ClassMethods.clear_caches_calculated_from_columns

```ruby
def clear_caches_calculated_from_columns
  @attributes_builder = nil
  @column_names = nil
  @column_types = nil
  @columns = nil
  @columns_hash = nil
  @content_columns = nil
  @default_attributes = nil
  @persistable_attribute_names = nil
  @attribute_names = nil
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:18
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:86</summary>

##### Movie.attribute_type_decorations

```ruby
define_method(name) { val }

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:22
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:42</summary>

##### ActiveRecord::AttributeDecorators::TypeDecorator#merge

```ruby
def merge(*args)
  TypeDecorator.new(@decorations.merge(*args))
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:22
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:38</summary>

##### ActiveRecord::AttributeDecorators::TypeDecorator#initialize

```ruby
def initialize(decorations = {})
  @decorations = decorations
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:43
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:83</summary>

##### ActiveRecord::Base.attribute_type_decorations=

```ruby
define_singleton_method("#{name}=") do |val|
  singleton_class.class_eval do
    remove_possible_method(name)
    define_method(name) { val }
  end

  if singleton_class?
    class_eval do
      remove_possible_method(name)
      define_method(name) do
        if instance_variable_defined? ivar
          instance_variable_get ivar
        else
          singleton_class.send name
        end
      end
    end
  end
  val
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/attribute_decorators.rb:22
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/remove_method.rb:2</summary>

##### Module.remove_possible_method

```ruby
def remove_possible_method(method)
  if method_defined?(method) || private_method_defined?(method)
    undef_method(method)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:85
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activemodel-4.2.10/lib/active_model/validations.rb:274</summary>

##### ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods.inherited

```ruby
def inherited(subclass)
  # We need to apply this decorator here, rather than on module inclusion. The closure
  # created by the matcher would otherwise evaluate for `ActiveRecord::Base`, not the
  # sub class being decorated. As such, changes to `time_zone_aware_attributes`, or
  # `skip_time_zone_conversion_for_attributes` would not be picked up.
  subclass.class_eval do
    matcher = ->(name, type) { create_time_zone_conversion_attribute?(name, type) }
    decorate_matching_attribute_types(matcher, :_time_zone_conversion) do |type|
      TimeZoneConverter.new(type)
    end
  end
  super
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/locking/optimistic.rb:186
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:86</summary>

##### ActiveRecord::Base._validators

```ruby
define_method(name) { val }

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activemodel-4.2.10/lib/active_model/validations.rb:275
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:83</summary>

##### ActiveRecord::Base._validators=

```ruby
define_singleton_method("#{name}=") do |val|
  singleton_class.class_eval do
    remove_possible_method(name)
    define_method(name) { val }
  end

  if singleton_class?
    class_eval do
      remove_possible_method(name)
      define_method(name) do
        if instance_variable_defined? ivar
          instance_variable_get ivar
        else
          singleton_class.send name
        end
      end
    end
  end
  val
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activemodel-4.2.10/lib/active_model/validations.rb:276
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/remove_method.rb:2</summary>

##### Module.remove_possible_method

```ruby
def remove_possible_method(method)
  if method_defined?(method) || private_method_defined?(method)
    undef_method(method)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:85
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:121</summary>

##### ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods.inherited

```ruby
def inherited(subclass)
  # We need to apply this decorator here, rather than on module inclusion. The closure
  # created by the matcher would otherwise evaluate for `ActiveRecord::Base`, not the
  # sub class being decorated. As such, changes to `time_zone_aware_attributes`, or
  # `skip_time_zone_conversion_for_attributes` would not be picked up.
  subclass.class_eval do
    matcher = ->(name, type) { create_time_zone_conversion_attribute?(name, type) }
    decorate_matching_attribute_types(matcher, :_time_zone_conversion) do |type|
      TimeZoneConverter.new(type)
    end
  end
  super
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activemodel-4.2.10/lib/active_model/validations.rb:277
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:117</summary>

##### ActiveRecord::Core::ClassMethods.initialize_find_by_cache

```ruby
def initialize_find_by_cache # :nodoc:
  self.find_by_statement_cache = {}.extend(Mutex_m)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:122
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:60</summary>

##### Mutex.extend_object

```ruby
def Mutex_m.extend_object(obj) # :nodoc:
  super
  obj.mu_extended
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:65</summary>

##### Mutex_m#mu_extended

```ruby
def mu_extended # :nodoc:
  unless (defined? locked? and
          defined? lock and
          defined? unlock and
          defined? try_lock and
          defined? synchronize)
    Mutex_m.define_aliases(singleton_class)
  end
  mu_initialize
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:62
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:45</summary>

##### Mutex.define_aliases

```ruby
def Mutex_m.define_aliases(cl) # :nodoc:
  cl.module_eval %q{
    alias locked? mu_locked?
    alias lock mu_lock
    alias unlock mu_unlock
    alias try_lock mu_try_lock
    alias synchronize mu_synchronize
  }
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:71
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:108</summary>

##### Mutex_m#mu_initialize

```ruby
def mu_initialize # :nodoc:
  @_mutex = Thread::Mutex.new
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/mutex_m.rb:73
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:83</summary>

##### ActiveRecord::Base.find_by_statement_cache=

```ruby
define_singleton_method("#{name}=") do |val|
  singleton_class.class_eval do
    remove_possible_method(name)
    define_method(name) { val }
  end

  if singleton_class?
    class_eval do
      remove_possible_method(name)
      define_method(name) do
        if instance_variable_defined? ivar
          instance_variable_get ivar
        else
          singleton_class.send name
        end
      end
    end
  end
  val
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/remove_method.rb:2</summary>

##### Module.remove_possible_method

```ruby
def remove_possible_method(method)
  if method_defined?(method) || private_method_defined?(method)
    undef_method(method)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:85
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:27</summary>

##### ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods.inherited

```ruby
def inherited(subclass)
  # We need to apply this decorator here, rather than on module inclusion. The closure
  # created by the matcher would otherwise evaluate for `ActiveRecord::Base`, not the
  # sub class being decorated. As such, changes to `time_zone_aware_attributes`, or
  # `skip_time_zone_conversion_for_attributes` would not be picked up.
  subclass.class_eval do
    matcher = ->(name, type) { create_time_zone_conversion_attribute?(name, type) }
    decorate_matching_attribute_types(matcher, :_time_zone_conversion) do |type|
      TimeZoneConverter.new(type)
    end
  end
  super
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:123
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:12</summary>

##### ActiveRecord::Delegation::DelegateCache.initialize_relation_delegate_cache

```ruby
def initialize_relation_delegate_cache # :nodoc:
  @relation_delegate_cache = cache = {}
  [
    ActiveRecord::Relation,
    ActiveRecord::Associations::CollectionProxy,
    ActiveRecord::AssociationRelation
  ].each do |klass|
    delegate = Class.new(klass) {
      include ClassSpecificRelation
    }
    const_set klass.name.gsub('::', '_'), delegate
    cache[klass] = delegate
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:28
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:15
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:2
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/finder_methods.rb:1
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/finder_methods.rb:2
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/spawn_methods.rb:1
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/spawn_methods.rb:2
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/spawn_methods.rb:3
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/merger.rb:1
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/merger.rb:2
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/query_methods.rb:1
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/query_methods.rb:2
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/query_methods.rb:3
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:107</summary>

##### ActiveSupport::Concern.extended

```ruby
def self.extended(base) #:nodoc:
  base.instance_variable_set(:@_dependencies, [])
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/query_methods.rb:7
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:93</summary>

##### Set#initialize

```ruby
def initialize(enum = nil, &block) # :yields: o
  @hash ||= Hash.new(false)

  enum.nil? and return

  if block
    do_with_enum(enum) { |o| add(block[o]) }
  else
    merge(enum)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/query_methods.rb:351
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:432</summary>

##### Set#merge

```ruby
def merge(enum)
  if enum.instance_of?(self.class)
    @hash.update(enum.instance_variable_get(:@hash))
  else
    do_with_enum(enum) { |o| add(o) }
  end

  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:101
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:122</summary>

##### Set#do_with_enum

```ruby
def do_with_enum(enum, &block) # :nodoc:
  if enum.respond_to?(:each_entry)
    enum.each_entry(&block) if block
  elsif enum.respond_to?(:each)
    enum.each(&block) if block
  else
    raise ArgumentError, "value must be enumerable"
  end
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:436
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:111</summary>

##### ActiveSupport::Concern.append_features

```ruby
def append_features(base)
  if base.instance_variable_defined?(:@_dependencies)
    base.instance_variable_get(:@_dependencies) << self
    return false
  else
    return false if base < self
    @_dependencies.each { |dep| base.send(:include, dep) }
    super
    base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods)
    base.class_eval(&@_included_block) if instance_variable_defined?(:@_included_block)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:124</summary>

##### ActiveSupport::Concern.included

```ruby
def included(base = nil, &block)
  if base.nil?
    raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block)

    @_included_block = block
  else
    super
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:111</summary>

##### ActiveSupport::Concern.append_features

```ruby
def append_features(base)
  if base.instance_variable_defined?(:@_dependencies)
    base.instance_variable_get(:@_dependencies) << self
    return false
  else
    return false if base < self
    @_dependencies.each { |dep| base.send(:include, dep) }
    super
    base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods)
    base.class_eval(&@_included_block) if instance_variable_defined?(:@_included_block)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:124</summary>

##### ActiveSupport::Concern.included

```ruby
def included(base = nil, &block)
  if base.nil?
    raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block)

    @_included_block = block
  else
    super
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:16
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/delegation.rb:151</summary>

##### Module.delegate

```ruby
def delegate(*methods)
  options = methods.pop
  unless options.is_a?(Hash) && to = options[:to]
    raise ArgumentError, 'Delegation needs a target. Supply an options hash with a :to key as the last argument (e.g. delegate :hello, to: :greeter).'
  end

  prefix, allow_nil = options.values_at(:prefix, :allow_nil)

  if prefix == true && to =~ /^[^a-z_]/
    raise ArgumentError, 'Can only automatically set the delegation prefix when delegating to a method.'
  end

  method_prefix = \
    if prefix
      "#{prefix == true ? to : prefix}_"
    else
      ''
    end

  file, line = caller.first.split(':', 2)
  line = line.to_i

  to = to.to_s
  to = "self.#{to}" if RUBY_RESERVED_WORDS.include?(to)

  methods.each do |method|
    # Attribute writer methods only accept one argument. Makes sure []=
    # methods still accept two arguments.
    definition = (method =~ /[^\]]=$/) ? 'arg' : '*args, &block'

    # The following generated method calls the target exactly once, storing
    # the returned value in a dummy variable.
    #
    # Reason is twofold: On one hand doing less calls is in general better.
    # On the other hand it could be that the target has side-effects,
    # whereas conceptually, from the user point of view, the delegator should
    # be doing one call.
    if allow_nil
      method_def = [
        "def #{method_prefix}#{method}(#{definition})",
        "_ = #{to}",
        "if !_.nil? || nil.respond_to?(:#{method})",
        "  _.#{method}(#{definition})",
        "end",
      "end"
      ].join ';'
    else
      exception = %(raise DelegationError, "#{self}##{method_prefix}#{method} delegated to #{to}.#{method}, but #{to} is nil: \#{self.inspect}")

      method_def = [
        "def #{method_prefix}#{method}(#{definition})",
        " _ = #{to}",
        "  _.#{method}(#{definition})",
        "rescue NoMethodError => e",
        "  if _.nil? && e.name == :#{method}",
        "    #{exception}",
        "  else",
        "    raise",
        "  end",
        "end"
      ].join ';'
    end

    module_eval(method_def, file, line)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/associations/collection_proxy.rb:31
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:253</summary>

##### Set#include?

```ruby
def include?(o)
  @hash[o]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/delegation.rb:174
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/delegation.rb:151</summary>

##### Module.delegate

```ruby
def delegate(*methods)
  options = methods.pop
  unless options.is_a?(Hash) && to = options[:to]
    raise ArgumentError, 'Delegation needs a target. Supply an options hash with a :to key as the last argument (e.g. delegate :hello, to: :greeter).'
  end

  prefix, allow_nil = options.values_at(:prefix, :allow_nil)

  if prefix == true && to =~ /^[^a-z_]/
    raise ArgumentError, 'Can only automatically set the delegation prefix when delegating to a method.'
  end

  method_prefix = \
    if prefix
      "#{prefix == true ? to : prefix}_"
    else
      ''
    end

  file, line = caller.first.split(':', 2)
  line = line.to_i

  to = to.to_s
  to = "self.#{to}" if RUBY_RESERVED_WORDS.include?(to)

  methods.each do |method|
    # Attribute writer methods only accept one argument. Makes sure []=
    # methods still accept two arguments.
    definition = (method =~ /[^\]]=$/) ? 'arg' : '*args, &block'

    # The following generated method calls the target exactly once, storing
    # the returned value in a dummy variable.
    #
    # Reason is twofold: On one hand doing less calls is in general better.
    # On the other hand it could be that the target has side-effects,
    # whereas conceptually, from the user point of view, the delegator should
    # be doing one call.
    if allow_nil
      method_def = [
        "def #{method_prefix}#{method}(#{definition})",
        "_ = #{to}",
        "if !_.nil? || nil.respond_to?(:#{method})",
        "  _.#{method}(#{definition})",
        "end",
      "end"
      ].join ';'
    else
      exception = %(raise DelegationError, "#{self}##{method_prefix}#{method} delegated to #{to}.#{method}, but #{to} is nil: \#{self.inspect}")

      method_def = [
        "def #{method_prefix}#{method}(#{definition})",
        " _ = #{to}",
        "  _.#{method}(#{definition})",
        "rescue NoMethodError => e",
        "  if _.nil? && e.name == :#{method}",
        "    #{exception}",
        "  else",
        "    raise",
        "  end",
        "end"
      ].join ';'
    end

    module_eval(method_def, file, line)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/associations/collection_proxy.rb:32
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:253</summary>

##### Set#include?

```ruby
def include?(o)
  @hash[o]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/delegation.rb:174
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:272</summary>

##### ActiveSupport::Dependencies::Loadable#require

```ruby
def require(file)
  result = false
  load_dependency(file) { result = super }
  result
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:17
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:236</summary>

##### ActiveSupport::Dependencies::Loadable#load_dependency

```ruby
def load_dependency(file)
  if Dependencies.load? && ActiveSupport::Dependencies.constant_watch_stack.watching?
    Dependencies.new_constants_in(Object) { yield }
  else
    yield
  end
rescue Exception => exception  # errors from loading file
  exception.blame_file! file if exception.respond_to? :blame_file!
  raise
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:274
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:311</summary>

##### ActiveSupport::Dependencies.load?

```ruby
def load?
  mechanism == :load
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.mechanism

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:312
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:99</summary>

##### ActiveSupport::Dependencies::WatchStack#watching?

```ruby
def watching?
  !@watching.empty?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:237
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:640</summary>

##### ActiveSupport::Dependencies.new_constants_in

```ruby
def new_constants_in(*descs)
  log_call(*descs)

  constant_watch_stack.watch_namespaces(descs)
  aborting = true

  begin
    yield # Now yield to the code that is to define new constants.
    aborting = false
  ensure
    new_constants = constant_watch_stack.new_constants

    log "New constants: #{new_constants * ', '}"
    return new_constants unless aborting

    log "Error during loading, removing partially loaded constants "
    new_constants.each { |c| remove_constant(c) }.clear
  end

  []
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:743</summary>

##### ActiveSupport::Dependencies.log_call

```ruby
def log_call(*args)
  if log_activity?
    arg_str = args.collect { |arg| arg.inspect } * ', '
    /in `([a-z_\?\!]+)'/ =~ caller(1).first
    selector = $1 || '<unknown>'
    log "called #{selector}(#{arg_str})"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:641
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:744
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:142</summary>

##### ActiveSupport::Dependencies::WatchStack#watch_namespaces

```ruby
def watch_namespaces(namespaces)
  @watching << namespaces.map do |namespace|
    module_name = Dependencies.to_constant_name(namespace)
    original_constants = Dependencies.qualified_const_defined?(module_name) ?
      Inflector.constantize(module_name).local_constants : []

    @stack[module_name] << original_constants
    module_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:643
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:664</summary>

##### ActiveSupport::Dependencies.to_constant_name

```ruby
def to_constant_name(desc) #:nodoc:
  case desc
    when String then desc.sub(/^::/, '')
    when Symbol then desc.to_s
    when Module
      desc.name ||
        raise(ArgumentError, "Anonymous modules have no name to be referenced by")
    else raise TypeError, "Not a valid constant descriptor: #{desc.inspect}"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:144
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:145
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:146
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:111</summary>

##### ActiveSupport::Concern.append_features

```ruby
def append_features(base)
  if base.instance_variable_defined?(:@_dependencies)
    base.instance_variable_get(:@_dependencies) << self
    return false
  else
    return false if base < self
    @_dependencies.each { |dep| base.send(:include, dep) }
    super
    base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods)
    base.class_eval(&@_included_block) if instance_variable_defined?(:@_included_block)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:20
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:124</summary>

##### ActiveSupport::Concern.included

```ruby
def included(base = nil, &block)
  if base.nil?
    raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block)

    @_included_block = block
  else
    super
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:20
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:111</summary>

##### ActiveSupport::Concern.append_features

```ruby
def append_features(base)
  if base.instance_variable_defined?(:@_dependencies)
    base.instance_variable_get(:@_dependencies) << self
    return false
  else
    return false if base < self
    @_dependencies.each { |dep| base.send(:include, dep) }
    super
    base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods)
    base.class_eval(&@_included_block) if instance_variable_defined?(:@_included_block)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:20
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:124</summary>

##### ActiveSupport::Concern.included

```ruby
def included(base = nil, &block)
  if base.nil?
    raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block)

    @_included_block = block
  else
    super
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:20
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:111</summary>

##### ActiveSupport::Concern.append_features

```ruby
def append_features(base)
  if base.instance_variable_defined?(:@_dependencies)
    base.instance_variable_get(:@_dependencies) << self
    return false
  else
    return false if base < self
    @_dependencies.each { |dep| base.send(:include, dep) }
    super
    base.extend const_get(:ClassMethods) if const_defined?(:ClassMethods)
    base.class_eval(&@_included_block) if instance_variable_defined?(:@_included_block)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:20
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/concern.rb:124</summary>

##### ActiveSupport::Concern.included

```ruby
def included(base = nil, &block)
  if base.nil?
    raise MultipleIncludedBlocks if instance_variable_defined?(:@_included_block)

    @_included_block = block
  else
    super
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:20
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/enum.rb:76</summary>

##### ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods.inherited

```ruby
def inherited(subclass)
  # We need to apply this decorator here, rather than on module inclusion. The closure
  # created by the matcher would otherwise evaluate for `ActiveRecord::Base`, not the
  # sub class being decorated. As such, changes to `time_zone_aware_attributes`, or
  # `skip_time_zone_conversion_for_attributes` would not be picked up.
  subclass.class_eval do
    matcher = ->(name, type) { create_time_zone_conversion_attribute?(name, type) }
    decorate_matching_attribute_types(matcher, :_time_zone_conversion) do |type|
      TimeZoneConverter.new(type)
    end
  end
  super
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:86</summary>

##### ActiveRecord::Base.defined_enums

```ruby
define_method(name) { val }

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/enum.rb:77
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/object/deep_dup.rb:41</summary>

##### Hash#deep_dup

```ruby
def deep_dup
  each_with_object(dup) do |(key, value), hash|
    hash[key.deep_dup] = value.deep_dup
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/enum.rb:77
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:83</summary>

##### ActiveRecord::Base.defined_enums=

```ruby
define_singleton_method("#{name}=") do |val|
  singleton_class.class_eval do
    remove_possible_method(name)
    define_method(name) { val }
  end

  if singleton_class?
    class_eval do
      remove_possible_method(name)
      define_method(name) do
        if instance_variable_defined? ivar
          instance_variable_get ivar
        else
          singleton_class.send name
        end
      end
    end
  end
  val
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/enum.rb:77
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/remove_method.rb:2</summary>

##### Module.remove_possible_method

```ruby
def remove_possible_method(method)
  if method_defined?(method) || private_method_defined?(method)
    undef_method(method)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:85
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/descendants_tracker.rb:47</summary>

##### ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods.inherited

```ruby
def inherited(subclass)
  # We need to apply this decorator here, rather than on module inclusion. The closure
  # created by the matcher would otherwise evaluate for `ActiveRecord::Base`, not the
  # sub class being decorated. As such, changes to `time_zone_aware_attributes`, or
  # `skip_time_zone_conversion_for_attributes` would not be picked up.
  subclass.class_eval do
    matcher = ->(name, type) { create_time_zone_conversion_attribute?(name, type) }
    decorate_matching_attribute_types(matcher, :_time_zone_conversion) do |type|
      TimeZoneConverter.new(type)
    end
  end
  super
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/enum.rb:78
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/descendants_tracker.rb:34</summary>

##### ActiveSupport::DescendantsTracker.store_inherited

```ruby
def store_inherited(klass, descendant)
  (@@direct_descendants[klass] ||= []) << descendant
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/descendants_tracker.rb:48
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.constant_watch_stack

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:105</summary>

##### ActiveSupport::Dependencies::WatchStack#new_constants

```ruby
def new_constants
  constants = []

  # Grab the list of namespaces that we're looking for new constants under
  @watching.last.each do |namespace|
    # Retrieve the constants that were present under the namespace when watch_namespaces
    # was originally called
    original_constants = @stack[namespace].last

    mod = Inflector.constantize(namespace) if Dependencies.qualified_const_defined?(namespace)
    next unless mod.is_a?(Module)

    # Get a list of the constants that were added
    new_constants = mod.local_constants - original_constants

    # self[namespace] returns an Array of the constants that are being evaluated
    # for that namespace. For instance, if parent.rb requires child.rb, the first
    # element of self[Object] will be an Array of the constants that were present
    # before parent.rb was required. The second element will be an Array of the
    # constants that were present before child.rb was required.
    @stack[namespace].each do |namespace_constants|
      namespace_constants.concat(new_constants)
    end

    # Normalize the list of new constants, and add them to the list we will return
    new_constants.each do |suffix|
      constants << ([namespace, suffix] - ["Object"]).join("::")
    end
  end
  constants
ensure
  # A call to new_constants is always called after a call to watch_namespaces
  pop_modules(@watching.pop)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:650
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:375</summary>

##### ActiveSupport::Dependencies.qualified_const_defined?

```ruby
def qualified_const_defined?(path)
  Object.qualified_const_defined?(path.sub(/^::/, ''), false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:26</summary>

##### Module.qualified_const_defined?

```ruby
def qualified_const_defined?(path, search_parents=true)
  QualifiedConstUtils.raise_if_absolute(path)

  QualifiedConstUtils.names(path).inject(self) do |mod, name|
    return unless mod.const_defined?(name, search_parents)
    mod.const_get(name)
  end
  return true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:376
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:7</summary>

##### QualifiedConstUtils.raise_if_absolute

```ruby
def self.raise_if_absolute(path)
  raise NameError.new("wrong constant name #$&") if path =~ /\A::[^:]+/
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:27
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:11</summary>

##### QualifiedConstUtils.names

```ruby
def self.names(path)
  path.split('::')
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/qualified_const.rb:29
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:250</summary>

##### ActiveSupport::Inflector.constantize

```ruby
def constantize(camel_cased_word)
  names = camel_cased_word.split('::')

  # Trigger a built-in NameError exception including the ill-formed constant in the message.
  Object.const_get(camel_cased_word) if names.empty?

  # Remove the first blank element in case of '::ClassName' notation.
  names.shift if names.size > 1 && names.first.empty?

  names.inject(Object) do |constant, name|
    if constant == Object
      constant.const_get(name)
    else
      candidate = constant.const_get(name)
      next candidate if constant.const_defined?(name, false)
      next candidate unless Object.const_defined?(name)

      # Go down the ancestors to check if it is owned directly. The check
      # stops when we reach Object or the end of ancestors tree.
      constant = constant.ancestors.inject do |const, ancestor|
        break const    if ancestor == Object
        break ancestor if ancestor.const_defined?(name, false)
        const
      end

      # owner is in Object, so raise
      constant.const_get(name, false)
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:114
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:59</summary>

##### Module.local_constants

```ruby
def local_constants #:nodoc:
  constants(false)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:118
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:154</summary>

##### ActiveSupport::Dependencies::WatchStack#pop_modules

```ruby
def pop_modules(modules)
  modules.each { |mod| @stack[mod].pop }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:137
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:652
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:423</summary>

##### ActiveSupport::Dependencies.load_once_path?

```ruby
def load_once_path?(path)
  # to_s works around a ruby1.9 issue where String#starts_with?(Pathname)
  # will raise a TypeError: no implicit conversion of Pathname into String
  autoload_once_paths.any? { |base| path.starts_with? base.to_s }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:460
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.autoload_once_paths

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:426
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.autoloaded_constants

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:460
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.autoloaded_constants

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:461
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:752</summary>

##### ActiveSupport::Dependencies.log

```ruby
def log(msg)
  logger.debug "Dependencies: #{msg}" if log_activity?
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:462
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:756</summary>

##### ActiveSupport::Dependencies.log_activity?

```ruby
def log_activity?
  logger && log_activity
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:753
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.logger

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:757
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.loading

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:366
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/attribute_accessors.rb:60</summary>

##### ActiveSupport::Dependencies.history

```ruby
def self.#{sym}
  @@#{sym}
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:370
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:348</summary>

##### Set#add

```ruby
def add(o)
  @hash[o] = true
  self
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/dependencies.rb:370
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/named.rb:24</summary>

##### ActiveRecord::Scoping::Named::ClassMethods.all

```ruby
def all
  if current_scope
    current_scope.clone
  else
    default_scoped
  end
end

# called from app/controllers/movies_controller.rb:11
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping.rb:13</summary>

##### ActiveRecord::Scoping::ClassMethods.current_scope

```ruby
def current_scope #:nodoc:
  ScopeRegistry.value_for(:current_scope, base_class.to_s)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/named.rb:25
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:100</summary>

##### ActiveRecord::Inheritance::ClassMethods.base_class

```ruby
def base_class
  unless self < Base
    raise ActiveRecordError, "#{name} doesn't belong in a hierarchy descending from ActiveRecord"
  end

  if superclass == Base || superclass.abstract_class?
    self
  else
    superclass.base_class
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping.rb:14
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/per_thread_registry.rb:46</summary>

##### ActiveSupport::PerThreadRegistry.method_missing

```ruby
def method_missing(name, *args, &block) # :nodoc:
  # Caches the method definition as a singleton method of the receiver.
  #
  # By letting #delegate handle it, we avoid an enclosure that'll capture args.
  singleton_class.delegate name, to: :instance

  send(name, *args, &block)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping.rb:14
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/delegation.rb:151</summary>

##### Module.delegate

```ruby
def delegate(*methods)
  options = methods.pop
  unless options.is_a?(Hash) && to = options[:to]
    raise ArgumentError, 'Delegation needs a target. Supply an options hash with a :to key as the last argument (e.g. delegate :hello, to: :greeter).'
  end

  prefix, allow_nil = options.values_at(:prefix, :allow_nil)

  if prefix == true && to =~ /^[^a-z_]/
    raise ArgumentError, 'Can only automatically set the delegation prefix when delegating to a method.'
  end

  method_prefix = \
    if prefix
      "#{prefix == true ? to : prefix}_"
    else
      ''
    end

  file, line = caller.first.split(':', 2)
  line = line.to_i

  to = to.to_s
  to = "self.#{to}" if RUBY_RESERVED_WORDS.include?(to)

  methods.each do |method|
    # Attribute writer methods only accept one argument. Makes sure []=
    # methods still accept two arguments.
    definition = (method =~ /[^\]]=$/) ? 'arg' : '*args, &block'

    # The following generated method calls the target exactly once, storing
    # the returned value in a dummy variable.
    #
    # Reason is twofold: On one hand doing less calls is in general better.
    # On the other hand it could be that the target has side-effects,
    # whereas conceptually, from the user point of view, the delegator should
    # be doing one call.
    if allow_nil
      method_def = [
        "def #{method_prefix}#{method}(#{definition})",
        "_ = #{to}",
        "if !_.nil? || nil.respond_to?(:#{method})",
        "  _.#{method}(#{definition})",
        "end",
      "end"
      ].join ';'
    else
      exception = %(raise DelegationError, "#{self}##{method_prefix}#{method} delegated to #{to}.#{method}, but #{to} is nil: \#{self.inspect}")

      method_def = [
        "def #{method_prefix}#{method}(#{definition})",
        " _ = #{to}",
        "  _.#{method}(#{definition})",
        "rescue NoMethodError => e",
        "  if _.nil? && e.name == :#{method}",
        "    #{exception}",
        "  else",
        "    raise",
        "  end",
        "end"
      ].join ';'
    end

    module_eval(method_def, file, line)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/per_thread_registry.rb:50
```
</details>
<details open>
<summary>/home/daniel/.rvm/rubies/ruby-2.6.6/lib/ruby/2.6.0/set.rb:253</summary>

##### Set#include?

```ruby
def include?(o)
  @hash[o]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/delegation.rb:174
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/per_thread_registry.rb:50</summary>

##### ActiveRecord::Scoping::ScopeRegistry.value_for

```ruby
singleton_class.delegate name, to: :instance

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/per_thread_registry.rb:52
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/per_thread_registry.rb:41</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/per_thread_registry.rb:50
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping.rb:62</summary>

##### ActiveRecord::Scoping::ScopeRegistry#initialize

```ruby
def initialize
  @registry = Hash.new { |hash, key| hash[key] = {} }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/per_thread_registry.rb:42
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping.rb:67</summary>

##### ActiveRecord::Scoping::ScopeRegistry#value_for

```ruby
def value_for(scope_type, variable_name)
  raise_invalid_scope_type!(scope_type)
  @registry[scope_type][variable_name]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/per_thread_registry.rb:50
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping.rb:80</summary>

##### ActiveRecord::Scoping::ScopeRegistry#raise_invalid_scope_type!

```ruby
def raise_invalid_scope_type!(scope_type)
  if !VALID_SCOPE_TYPES.include?(scope_type)
    raise ArgumentError, "Invalid scope type '#{scope_type}' sent to the registry. Scope types must be included in VALID_SCOPE_TYPES"
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping.rb:68
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/named.rb:32</summary>

##### ActiveRecord::Scoping::Named::ClassMethods.default_scoped

```ruby
def default_scoped # :nodoc:
  relation.merge(build_default_scope)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/named.rb:28
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:253</summary>

##### ActiveRecord::Core::ClassMethods.relation

```ruby
def relation #:nodoc:
  relation = Relation.create(self, arel_table)

  if finder_needs_type_condition?
    relation.where(type_condition).create_with(inheritance_column.to_sym => sti_name)
  else
    relation
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/named.rb:33
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:237</summary>

##### ActiveRecord::Core::ClassMethods.arel_table

```ruby
def arel_table # :nodoc:
  @arel_table ||= Arel::Table.new(table_name, arel_engine)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:254
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:125</summary>

##### ActiveRecord::ModelSchema::ClassMethods.table_name

```ruby
def table_name
  reset_table_name unless defined?(@table_name)
  @table_name
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:159</summary>

##### ActiveRecord::ModelSchema::ClassMethods.reset_table_name

```ruby
def reset_table_name #:nodoc:
  self.table_name = if abstract_class?
    superclass == Base ? nil : superclass.table_name
  elsif superclass.abstract_class?
    superclass.table_name || compute_table_name
  else
    compute_table_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:126
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:130</summary>

##### ActiveRecord::Inheritance::ClassMethods.abstract_class?

```ruby
def abstract_class?
  defined?(@abstract_class) && @abstract_class == true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:160
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:130</summary>

##### ActiveRecord::Inheritance::ClassMethods.abstract_class?

```ruby
def abstract_class?
  defined?(@abstract_class) && @abstract_class == true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:162
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:320</summary>

##### ActiveRecord::ModelSchema::ClassMethods.compute_table_name

```ruby
def compute_table_name
  base = base_class
  if self == base
    # Nested classes are prefixed with singular parent table name.
    if parent < Base && !parent.abstract_class?
      contained = parent.table_name
      contained = contained.singularize if parent.pluralize_table_names
      contained += '_'
    end

    "#{full_table_name_prefix}#{contained}#{undecorated_table_name(name)}#{full_table_name_suffix}"
  else
    # STI subclasses always use their superclass' table.
    base.table_name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:165
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:100</summary>

##### ActiveRecord::Inheritance::ClassMethods.base_class

```ruby
def base_class
  unless self < Base
    raise ActiveRecordError, "#{name} doesn't belong in a hierarchy descending from ActiveRecord"
  end

  if superclass == Base || superclass.abstract_class?
    self
  else
    superclass.base_class
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:321
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:30</summary>

##### Module.parent

```ruby
def parent
  parent_name ? ActiveSupport::Inflector.constantize(parent_name) : Object
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:324
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:7</summary>

##### Module.parent_name

```ruby
def parent_name
  if defined? @parent_name
    @parent_name
  else
    @parent_name = name =~ /::[^:]+\Z/ ? $`.freeze : nil
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:31
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:169</summary>

##### ActiveRecord::ModelSchema::ClassMethods.full_table_name_prefix

```ruby
def full_table_name_prefix #:nodoc:
  (parents.detect{ |p| p.respond_to?(:table_name_prefix) } || self).table_name_prefix
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:330
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:46</summary>

##### Module.parents

```ruby
def parents
  parents = []
  if parent_name
    parts = parent_name.split('::')
    until parts.empty?
      parents << ActiveSupport::Inflector.constantize(parts * '::')
      parts.pop
    end
  end
  parents << Object unless parents.include? Object
  parents
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:170
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:7</summary>

##### Module.parent_name

```ruby
def parent_name
  if defined? @parent_name
    @parent_name
  else
    @parent_name = name =~ /::[^:]+\Z/ ? $`.freeze : nil
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:48
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:86</summary>

##### ActiveRecord::Base.table_name_prefix

```ruby
define_method(name) { val }

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:170
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:314</summary>

##### ActiveRecord::ModelSchema::ClassMethods.undecorated_table_name

```ruby
def undecorated_table_name(class_name = base_class.name)
  table_name = class_name.to_s.demodulize.underscore
  pluralize_table_names ? table_name.pluralize : table_name
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:330
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:137</summary>

##### String#demodulize

```ruby
def demodulize
  ActiveSupport::Inflector.demodulize(self)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:315
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:199</summary>

##### ActiveSupport::Inflector.demodulize

```ruby
def demodulize(path)
  path = path.to_s
  if i = path.rindex('::')
    path[(i+2)..-1]
  else
    path
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:138
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:118</summary>

##### String#underscore

```ruby
def underscore
  ActiveSupport::Inflector.underscore(self)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:315
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:91</summary>

##### ActiveSupport::Inflector.underscore

```ruby
def underscore(camel_cased_word)
  return camel_cased_word unless camel_cased_word =~ /[A-Z-]|::/
  word = camel_cased_word.to_s.gsub(/::/, '/')
  word.gsub!(/(?:(?<=([A-Za-z\d]))|\b)(#{inflections.acronym_regex})(?=\b|[^a-z])/) { "#{$1 && '_'}#{$2.downcase}" }
  word.gsub!(/([A-Z\d]+)([A-Z][a-z])/,'\1_\2')
  word.gsub!(/([a-z\d])([A-Z])/,'\1_\2')
  word.tr!("-", "_")
  word.downcase!
  word
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:119
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:203</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:94
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:30</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:207
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:31
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:86</summary>

##### ActiveRecord::Base.pluralize_table_names

```ruby
define_method(name) { val }

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:316
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:31</summary>

##### String#pluralize

```ruby
def pluralize(count = nil, locale = :en)
  locale = count if count.is_a?(Symbol)
  if count == 1
    self.dup
  else
    ActiveSupport::Inflector.pluralize(self, locale)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:316
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:31</summary>

##### ActiveSupport::Inflector.pluralize

```ruby
def pluralize(word, locale = :en)
  apply_inflections(word, inflections(locale).plurals)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/string/inflections.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:203</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:32
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:30</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:207
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:31
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:372</summary>

##### ActiveSupport::Inflector.apply_inflections

```ruby
def apply_inflections(word, rules)
  result = word.to_s.dup

  if word.empty? || inflections.uncountables.include?(result.downcase[/\b\w+\Z/])
    result
  else
    rules.each { |(rule, replacement)| break if result.sub!(rule, replacement) }
    result
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:32
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:203</summary>

##### ActiveSupport::Inflector.inflections

```ruby
def inflections(locale = :en)
  if block_given?
    yield Inflections.instance(locale)
  else
    Inflections.instance(locale)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/methods.rb:375
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:30</summary>

##### ActiveSupport::Inflector::Inflections.instance

```ruby
def self.instance(locale = :en)
  @__instance__[locale] ||= new
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:207
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/inflector/inflections.rb:31
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:173</summary>

##### ActiveRecord::ModelSchema::ClassMethods.full_table_name_suffix

```ruby
def full_table_name_suffix #:nodoc:
  (parents.detect {|p| p.respond_to?(:table_name_suffix) } || self).table_name_suffix
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:330
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:46</summary>

##### Module.parents

```ruby
def parents
  parents = []
  if parent_name
    parts = parent_name.split('::')
    until parts.empty?
      parents << ActiveSupport::Inflector.constantize(parts * '::')
      parts.pop
    end
  end
  parents << Object unless parents.include? Object
  parents
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:174
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:7</summary>

##### Module.parent_name

```ruby
def parent_name
  if defined? @parent_name
    @parent_name
  else
    @parent_name = name =~ /::[^:]+\Z/ ? $`.freeze : nil
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/module/introspection.rb:48
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:86</summary>

##### ActiveRecord::Base.table_name_suffix

```ruby
define_method(name) { val }

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:174
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:138</summary>

##### ActiveRecord::ModelSchema::ClassMethods.table_name=

```ruby
def table_name=(value)
  value = value && value.to_s

  if defined?(@table_name)
    return if value == @table_name
    reset_column_information if connected?
  end

  @table_name        = value
  @quoted_table_name = nil
  @arel_table        = nil
  @sequence_name     = nil unless defined?(@explicit_sequence_name) && @explicit_sequence_name
  @relation          = Relation.create(self, arel_table)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:160
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:237</summary>

##### ActiveRecord::Core::ClassMethods.arel_table

```ruby
def arel_table # :nodoc:
  @arel_table ||= Arel::Table.new(table_name, arel_engine)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:150
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:125</summary>

##### ActiveRecord::ModelSchema::ClassMethods.table_name

```ruby
def table_name
  reset_table_name unless defined?(@table_name)
  @table_name
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:242</summary>

##### ActiveRecord::Core::ClassMethods.arel_engine

```ruby
def arel_engine # :nodoc:
  @arel_engine ||=
    if Base == self || connection_handler.retrieve_connection_pool(self)
      self
    else
      superclass.arel_engine
    end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:100</summary>

##### ActiveRecord::Base.connection_handler

```ruby
def self.connection_handler
  ActiveRecord::RuntimeRegistry.connection_handler || default_connection_handler
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:244
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/runtime_registry.rb:18</summary>

##### ActiveRecord::RuntimeRegistry.connection_handler

```ruby
class_eval %{ def self.#{val}; instance.#{val}; end }, __FILE__, __LINE__

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:101
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/per_thread_registry.rb:41</summary>

##### ActiveSupport::PerThreadRegistry.instance

```ruby
def instance
  Thread.current[@per_thread_registry_key] ||= new
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/runtime_registry.rb:18
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:86</summary>

##### ActiveRecord::Base.default_connection_handler

```ruby
define_method(name) { val }

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:101
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:605</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#retrieve_connection_pool

```ruby
def retrieve_connection_pool(klass)
  class_to_pool[klass.name] ||= begin
    until pool = pool_for(klass)
      klass = klass.superclass
      break unless klass <= Base
    end

    class_to_pool[klass.name] = pool
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:244
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:622</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#class_to_pool

```ruby
def class_to_pool
  @class_to_pool[Process.pid]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:606
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:623
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:606
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:626</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#pool_for

```ruby
def pool_for(owner)
  owner_to_pool.fetch(owner.name) {
    if ancestor_pool = pool_from_any_process_for(owner)
      # A connection was established in an ancestor process that must have
      # subsequently forked. We can't reuse the connection, but we can copy
      # the specification and establish a new connection with it.
      establish_connection owner, ancestor_pool.spec
    else
      owner_to_pool[owner.name] = nil
    end
  }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:607
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:618</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:627
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:619
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:52</summary>

##### ThreadSafe::Cache#fetch

```ruby
def fetch(key, default_value = NULL)
  if NULL != (value = get_or_default(key, NULL))
    value
  elsif block_given?
    yield key
  elsif NULL != default_value
    default_value
  else
    raise_fetch_no_key
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:627
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:104</summary>

##### ThreadSafe::NonConcurrentCacheBackend#get_or_default

```ruby
def get_or_default(key, default_value)
  @backend.fetch(key, default_value)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:53
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:639</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#pool_from_any_process_for

```ruby
def pool_from_any_process_for(owner)
  owner_to_pool = @owner_to_pool.values.reverse.find { |v| v[owner.name] }
  owner_to_pool && owner_to_pool[owner.name]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:628
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:92</summary>

##### ThreadSafe::Cache#values

```ruby
def values
  arr = []
  each_pair {|k, v| arr << v}
  arr
end unless method_defined?(:values)

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:640
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:93</summary>

##### ThreadSafe::NonConcurrentCacheBackend#each_pair

```ruby
def each_pair
  dupped_backend.each_pair do |k, v|
    yield k, v
  end
  self
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:94
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:118</summary>

##### ThreadSafe::NonConcurrentCacheBackend#dupped_backend

```ruby
def dupped_backend
  @backend.dup
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:94
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:640
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:618</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:634
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:619
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/mri_cache_backend.rb:12</summary>

##### ThreadSafe::MriCacheBackend#[]=

```ruby
def []=(key, value)
  WRITE_LOCK.synchronize { super }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:634
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:15</summary>

##### ThreadSafe::MriCacheBackend#[]=

```ruby
def []=(key, value)
  WRITE_LOCK.synchronize { super }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/mri_cache_backend.rb:13
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:626</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#pool_for

```ruby
def pool_for(owner)
  owner_to_pool.fetch(owner.name) {
    if ancestor_pool = pool_from_any_process_for(owner)
      # A connection was established in an ancestor process that must have
      # subsequently forked. We can't reuse the connection, but we can copy
      # the specification and establish a new connection with it.
      establish_connection owner, ancestor_pool.spec
    else
      owner_to_pool[owner.name] = nil
    end
  }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:607
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:618</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#owner_to_pool

```ruby
def owner_to_pool
  @owner_to_pool[Process.pid]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:627
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:619
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:52</summary>

##### ThreadSafe::Cache#fetch

```ruby
def fetch(key, default_value = NULL)
  if NULL != (value = get_or_default(key, NULL))
    value
  elsif block_given?
    yield key
  elsif NULL != default_value
    default_value
  else
    raise_fetch_no_key
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:627
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:104</summary>

##### ThreadSafe::NonConcurrentCacheBackend#get_or_default

```ruby
def get_or_default(key, default_value)
  @backend.fetch(key, default_value)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:53
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:622</summary>

##### ActiveRecord::ConnectionAdapters::ConnectionHandler#class_to_pool

```ruby
def class_to_pool
  @class_to_pool[Process.pid]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:612
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:35</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:623
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:11</summary>

##### ThreadSafe::Cache#[]

```ruby
def [](key)
  if value = super # non-falsy value is an existing mapping, return it right away
    value
  # re-check is done with get_or_default(key, NULL) instead of a simple !key?(key) in order to avoid a race condition, whereby by the time the current thread gets to the key?(key) call
  # a key => value mapping might have already been created by a different thread (key?(key) would then return true, this elsif branch wouldn't be taken and an incorrent +nil+ value
  # would be returned)
  # note: nil == value check is not technically necessary
  elsif @default_proc && nil == value && NULL == (value = get_or_default(key, NULL))
    @default_proc.call(self, key)
  else
    value
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/cache.rb:36
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/mri_cache_backend.rb:12</summary>

##### ThreadSafe::MriCacheBackend#[]=

```ruby
def []=(key, value)
  WRITE_LOCK.synchronize { super }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:612
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:15</summary>

##### ThreadSafe::MriCacheBackend#[]=

```ruby
def []=(key, value)
  WRITE_LOCK.synchronize { super }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/mri_cache_backend.rb:13
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/mri_cache_backend.rb:12</summary>

##### ThreadSafe::MriCacheBackend#[]=

```ruby
def []=(key, value)
  WRITE_LOCK.synchronize { super }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/connection_adapters/abstract/connection_pool.rb:606
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/non_concurrent_cache_backend.rb:15</summary>

##### ThreadSafe::MriCacheBackend#[]=

```ruby
def []=(key, value)
  WRITE_LOCK.synchronize { super }
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/thread_safe-0.3.6/lib/thread_safe/mri_cache_backend.rb:13
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/arel-6.0.4/lib/arel/table.rb:14</summary>

##### Arel::Table#initialize

```ruby
def initialize name, engine = Table.engine
  @name    = name.to_s
  @engine  = engine
  @columns = nil
  @aliases = []
  @table_alias = nil
  @primary_key = nil

  if Hash === engine
    @engine  = engine[:engine] || Table.engine

    # Sometime AR sends an :as parameter to table, to let the table know
    # that it is an Alias.  We may want to override new, and return a
    # TableAlias node?
    @table_alias = engine[:as] unless engine[:as].to_s == @name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:105</summary>

##### ActiveRecord::Delegation::ClassMethods.create

```ruby
def create(klass, *args)
  relation_class_for(klass).new(klass, *args)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/model_schema.rb:150
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:111</summary>

##### ActiveRecord::Delegation::ClassMethods.relation_class_for

```ruby
def relation_class_for(klass)
  klass.relation_delegate_class(self)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:106
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:8</summary>

##### ActiveRecord::Delegation::DelegateCache.relation_delegate_class

```ruby
def relation_delegate_class(klass) # :nodoc:
  @relation_delegate_cache[klass]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:112
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:23</summary>

##### ActiveRecord::Relation#initialize

```ruby
def initialize(klass, table, values = {})
  @klass  = klass
  @table  = table
  @values = values
  @offsets = {}
  @loaded = false
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:106
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:242</summary>

##### ActiveRecord::Core::ClassMethods.arel_engine

```ruby
def arel_engine # :nodoc:
  @arel_engine ||=
    if Base == self || connection_handler.retrieve_connection_pool(self)
      self
    else
      superclass.arel_engine
    end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/arel-6.0.4/lib/arel/table.rb:14</summary>

##### Arel::Table#initialize

```ruby
def initialize name, engine = Table.engine
  @name    = name.to_s
  @engine  = engine
  @columns = nil
  @aliases = []
  @table_alias = nil
  @primary_key = nil

  if Hash === engine
    @engine  = engine[:engine] || Table.engine

    # Sometime AR sends an :as parameter to table, to let the table know
    # that it is an Alias.  We may want to override new, and return a
    # TableAlias node?
    @table_alias = engine[:as] unless engine[:as].to_s == @name
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:238
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:105</summary>

##### ActiveRecord::Delegation::ClassMethods.create

```ruby
def create(klass, *args)
  relation_class_for(klass).new(klass, *args)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:254
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:111</summary>

##### ActiveRecord::Delegation::ClassMethods.relation_class_for

```ruby
def relation_class_for(klass)
  klass.relation_delegate_class(self)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:106
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:8</summary>

##### ActiveRecord::Delegation::DelegateCache.relation_delegate_class

```ruby
def relation_delegate_class(klass) # :nodoc:
  @relation_delegate_cache[klass]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:112
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:23</summary>

##### ActiveRecord::Relation#initialize

```ruby
def initialize(klass, table, values = {})
  @klass  = klass
  @table  = table
  @values = values
  @offsets = {}
  @loaded = false
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:106
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:77</summary>

##### ActiveRecord::Inheritance::ClassMethods.finder_needs_type_condition?

```ruby
def finder_needs_type_condition? #:nodoc:
  # This is like this because benchmarking justifies the strange :false stuff
  :true == (@finder_needs_type_condition ||= descends_from_active_record? ? :false : :true)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:256
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:67</summary>

##### ActiveRecord::Inheritance::ClassMethods.descends_from_active_record?

```ruby
def descends_from_active_record?
  if self == Base
    false
  elsif superclass.abstract_class?
    superclass.descends_from_active_record?
  else
    superclass == Base || !columns_hash.include?(inheritance_column)
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:79
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:130</summary>

##### ActiveRecord::Inheritance::ClassMethods.abstract_class?

```ruby
def abstract_class?
  defined?(@abstract_class) && @abstract_class == true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:70
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:253</summary>

##### ActiveRecord::Core::ClassMethods.relation

```ruby
def relation #:nodoc:
  relation = Relation.create(self, arel_table)

  if finder_needs_type_condition?
    relation.where(type_condition).create_with(inheritance_column.to_sym => sti_name)
  else
    relation
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/default.rb:97
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:237</summary>

##### ActiveRecord::Core::ClassMethods.arel_table

```ruby
def arel_table # :nodoc:
  @arel_table ||= Arel::Table.new(table_name, arel_engine)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:254
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:105</summary>

##### ActiveRecord::Delegation::ClassMethods.create

```ruby
def create(klass, *args)
  relation_class_for(klass).new(klass, *args)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:254
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:111</summary>

##### ActiveRecord::Delegation::ClassMethods.relation_class_for

```ruby
def relation_class_for(klass)
  klass.relation_delegate_class(self)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:106
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:8</summary>

##### ActiveRecord::Delegation::DelegateCache.relation_delegate_class

```ruby
def relation_delegate_class(klass) # :nodoc:
  @relation_delegate_cache[klass]
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:112
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation.rb:23</summary>

##### ActiveRecord::Relation#initialize

```ruby
def initialize(klass, table, values = {})
  @klass  = klass
  @table  = table
  @values = values
  @offsets = {}
  @loaded = false
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/delegation.rb:106
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:77</summary>

##### ActiveRecord::Inheritance::ClassMethods.finder_needs_type_condition?

```ruby
def finder_needs_type_condition? #:nodoc:
  # This is like this because benchmarking justifies the strange :false stuff
  :true == (@finder_needs_type_condition ||= descends_from_active_record? ? :false : :true)
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/core.rb:256
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/default.rb:97</summary>

##### ActiveRecord::Scoping::Default::ClassMethods.build_default_scope

```ruby
def build_default_scope(base_rel = relation) # :nodoc:
  return if abstract_class?
  if !Base.is_a?(method(:default_scope).owner)
    # The user has defined their own default scope method, so call that
    evaluate_default_scope { default_scope }
  elsif default_scopes.any?
    evaluate_default_scope do
      default_scopes.inject(base_rel) do |default_scope, scope|
        default_scope.merge(base_rel.scoping { scope.call })
      end
    end
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/named.rb:33
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/inheritance.rb:130</summary>

##### ActiveRecord::Inheritance::ClassMethods.abstract_class?

```ruby
def abstract_class?
  defined?(@abstract_class) && @abstract_class == true
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/default.rb:98
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activesupport-4.2.10/lib/active_support/core_ext/class/attribute.rb:86</summary>

##### ActiveRecord::Base.default_scopes

```ruby
define_method(name) { val }

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/default.rb:102
```
</details>
<details open>
<summary>/home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/relation/spawn_methods.rb:30</summary>

##### ActiveRecord::SpawnMethods#merge

```ruby
def merge(other)
  if other.is_a?(Array)
    to_a & other
  elsif other
    spawn.merge!(other)
  else
    self
  end
end

# called from /home/daniel/.rvm/gems/ruby-2.6.6/gems/activerecord-4.2.10/lib/active_record/scoping/named.rb:33
```
</details>
